/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⣀⣀⡤⠤⠖⠖⠖⠦⢤⠤⠲⠲⠲⠲⠦⢤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠖⠊⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡰⠚⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⡴⠊⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⣄⠀⠀⠀⠀⠀⡗⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⡶⢤⠤⠚⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣄⡀⠀⠀⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣻⡏⠀⠀⠈⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⡁⠀⠀⠀⠀⠀⢐⡇⠀⠀⠀⠀⢀⣠⣠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠀⠀⠀⢺⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠘⡆⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⢸⣯⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠻⣄⣀⣀⡤⡞⠁⠀⠀⠀⠀⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠁⠁⠀⠸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢨⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⠀⠀⠀⣀⡴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣆⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⢤⢤⣺⠴⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠦⣤⣀⡀⠀⠀⠀⠀⢀⣀⣄⣿⡾⠾⠋⠋⠱⡄⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠉⠛⠛⠋⠋⠉⠉⠈⠀⠀⠀⠀⠀⣸⢣⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡄⠀⢐⡇⠀⠀⠀⠀⠀⠀⠀⠀⢠⠏⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠲⡞⠀⠀⠀⠀⠀⠀⠀⠀⣠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠶⠴⠴⣆⠀⣴⡀⡯⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠋⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 */



#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<vector>
#include<unordered_map>
using namespace std;



int dx[4] = {-1, 0, 0, 1};
int dy[4] = {0, -1, 1, 0};

int n;

int r = 0;

// 학생의 위치
unordered_map<int, pair<int,int>> location;

long long calc(int x) {
 if (x == 0) return 0;
 else if (x == 1) return 1;
 else if (x == 2) return 10;
 else if (x == 3) return 100;
 else return 1000;
}

// 조건을 만족하는 x, y 위치 조합을 출력한다
// student : 좋아하는 사람들
// student_index : 자리 배정하려는 학생
// student_location : 지금 반에서 자리 배정이 어떻게 되어 있는지
vector<pair<int,int>> find_favorite_location(vector<vector<int>> &student, vector<vector<int>> &student_location, int student_index) {
 // 주변에 선호하는 사람이 몇명 있는지
 vector<vector<int>> favorite_count(n, vector<int> (n, 0));

 int max_count = 0;

 for (auto &p: student[student_index]) {
  // 아직 좋아하는 학생이 배치되지 않음
  if (location.find(p) == location.end()) continue;
  int x, y;
  tie(x, y) = location[p];
  // 좋아하는 사람들의 상하좌우 확인
  for (int i=0;i<4;i++) {
   int nx = x + dx[i];
   int ny = y + dy[i];

   // 교실 범위를 넘어갔을 때
   if (nx < 0 || ny < 0 || n <= nx || n <= ny) continue;
   // 해당 자리가 빈자리가 아닐 경우
   if (student_location[nx][ny] != 0) continue;
   favorite_count[nx][ny]++;
   max_count = max(max_count, favorite_count[nx][ny]);
  }
 }
 // r += calc(max_count);
 vector<pair<int,int>> result;
 for (int i=0;i<n;i++) {
  for (int j=0;j<n;j++) {
   if (favorite_count[i][j] == max_count && student_location[i][j] == 0) {
    result.push_back({i, j});
   }
  }
 }
 return result;
}

// 위치 후보 중 가장 주변에 빈 공간이 많고, 행, 열이 작은 위치 출력
// student : 좋아하는 사람들
// student_index : 자리 배정하려는 학생
// candidate : 후보 위치
pair<int,int> find_more_empty(vector<vector<int>> &student, vector<vector<int>> &student_location, vector<pair<int,int>> candidate) {
 vector<vector<int>> empty_count(n, vector<int> (n, 0));
 // for (int x = 0; x < n; x++) {
 //  for (int y = 0; y < n; y++) {
 //   for (int i = 0; i < 4; i++) {
 //    int nx = x + dx[i];
 //    int ny = y + dy[i];
 //    // 교실 범위를 넘어갔을 때
 //    if (nx < 0 || ny < 0 || n <= nx || n <= ny) continue;
 //    // 해당 자리가 빈자리가 아닐 경우
 //    if (student_location[nx][ny] != 0) continue;
 //    empty_count[x][y]++;
 //    // max_empty = max(max_empty, empty_count[nx][ny]);
 //   }
 //  }
 // }

 sort(candidate.begin(),candidate.end());

 int max_empty = -1;
 int r_x, r_y;
 for (auto &a: candidate) {
  int x, y;
  tie(x, y) = a;
  for (int i=0;i<4;i++) {
   int nx = x + dx[i];
   int ny = y + dy[i];
   if (nx < 0 || ny < 0 || n <= nx || n <= ny) continue;
   // 해당 자리가 빈자리가 아닐 경우
   if (student_location[nx][ny] != 0) continue;
   empty_count[x][y]++;
  }
  if (max_empty == -1 || max_empty < empty_count[x][y]) {
   r_x = x; r_y = y;
   max_empty = empty_count[x][y];
  }
 }
 return {r_x, r_y};
 // for (auto & a : candidate) {
 //  if (empty_count[a.first][a.second] > max_empty) {
 //   x = a.first; y = a.second;
 //   cout << x << " " << y << " " << empty_count[x][y] << "\n";
 //   max_empty = empty_count[x][y];
 //  }
 // }
 // return {x, y};

 // for (int x = 0; x < n; x++) {
 //  for (int y = 0; y < n; y++) {
 //   if (empty_count[x][y] == max_empty) return {x, y};
 //  }
 // }
}

int main() {
 cin >> n;
 int N = pow(n, 2);

 // 좋아하는 학생
 vector<vector<int>> student(N + 1, vector<int> (4));

 // 지금 교실에 앉아 있는 구조
 vector<vector<int>> student_location(n, vector<int> (n, 0));
 vector<int> order(N);
 for (int i=0;i<N;i++) {
  cin >> order[i];
  for (int j = 0; j < 4; j++) {
   cin >> student[order[i]][j];
  }
 }

 for (int i=0;i<N;i++) {
  // 현재 배치하려는 학생이 조건을 만족하면서 위치하는 곳
  vector<pair<int,int>> tmp_location = find_favorite_location(student, student_location, order[i]);
  // cout<<order[i]<<"\n";
  // for (auto a : tmp_location) {
  //  cout<<a.first<<" "<<a.second<<"\n";
  // }
  int x, y;
  // 최종 위치 판별
  tie(x, y) = find_more_empty(student, student_location, tmp_location);
  // cout<<"final: "<<x<<" "<<y<<"\n";
  location[order[i]] = {x, y};
  student_location[x][y] = order[i];
  // for (auto &a: student_location) {
  //  for (auto &b: a) {
  //   cout<<b<<" ";
  //  }
  //  cout<<"\n";
  // }
  // cout << "\n";
 }

 for (int i=0;i<n;i++) {
  for (int j=0;j<n;j++) {
   int count = 0;
   for (int z=0;z<4;z++) {
    int nx = i + dx[z];
    int ny = j + dy[z];
    if (nx < 0 || ny < 0 || n <= nx || n <= ny) continue;
    for (int q = 0; q < 4; q++) {
     if (student[student_location[i][j]][q] == student_location[nx][ny]) count++;
    }
   }
   r += calc(count);
  }
 }

 cout << r << "\n";
}